{"ast":null,"code":"'use strict';\n\nmodule.exports = factory;\n\nfunction factory(file) {\n  var contents = indices(String(file));\n  var toPoint = offsetToPointFactory(contents);\n  return {\n    toPoint: toPoint,\n    toPosition: toPoint,\n    toOffset: pointToOffsetFactory(contents)\n  };\n} // Factory to get the line and column-based `point` for `offset` in the bound\n// indices.\n\n\nfunction offsetToPointFactory(indices) {\n  return offsetToPoint; // Get the line and column-based `point` for `offset` in the bound indices.\n\n  function offsetToPoint(offset) {\n    var index = -1;\n    var length = indices.length;\n\n    if (offset < 0) {\n      return {};\n    }\n\n    while (++index < length) {\n      if (indices[index] > offset) {\n        return {\n          line: index + 1,\n          column: offset - (indices[index - 1] || 0) + 1,\n          offset: offset\n        };\n      }\n    }\n\n    return {};\n  }\n} // Factory to get the `offset` for a line and column-based `point` in the\n// bound indices.\n\n\nfunction pointToOffsetFactory(indices) {\n  return pointToOffset; // Get the `offset` for a line and column-based `point` in the bound\n  // indices.\n\n  function pointToOffset(point) {\n    var line = point && point.line;\n    var column = point && point.column;\n\n    if (!isNaN(line) && !isNaN(column) && line - 1 in indices) {\n      return (indices[line - 2] || 0) + column - 1 || 0;\n    }\n\n    return -1;\n  }\n} // Get indices of line-breaks in `value`.\n\n\nfunction indices(value) {\n  var result = [];\n  var index = value.indexOf('\\n');\n\n  while (index !== -1) {\n    result.push(index + 1);\n    index = value.indexOf('\\n', index + 1);\n  }\n\n  result.push(value.length + 1);\n  return result;\n}","map":{"version":3,"sources":["/Users/Saul/Desktop/shack2/node_modules/vfile-location/index.js"],"names":["module","exports","factory","file","contents","indices","String","toPoint","offsetToPointFactory","toPosition","toOffset","pointToOffsetFactory","offsetToPoint","offset","index","length","line","column","pointToOffset","point","isNaN","value","result","indexOf","push"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,OAAP,GAAiBC,OAAjB;;AAEA,SAASA,OAAT,CAAiBC,IAAjB,EAAuB;AACrB,MAAIC,QAAQ,GAAGC,OAAO,CAACC,MAAM,CAACH,IAAD,CAAP,CAAtB;AACA,MAAII,OAAO,GAAGC,oBAAoB,CAACJ,QAAD,CAAlC;AAEA,SAAO;AACLG,IAAAA,OAAO,EAAEA,OADJ;AAELE,IAAAA,UAAU,EAAEF,OAFP;AAGLG,IAAAA,QAAQ,EAAEC,oBAAoB,CAACP,QAAD;AAHzB,GAAP;AAKD,C,CAED;AACA;;;AACA,SAASI,oBAAT,CAA8BH,OAA9B,EAAuC;AACrC,SAAOO,aAAP,CADqC,CAGrC;;AACA,WAASA,aAAT,CAAuBC,MAAvB,EAA+B;AAC7B,QAAIC,KAAK,GAAG,CAAC,CAAb;AACA,QAAIC,MAAM,GAAGV,OAAO,CAACU,MAArB;;AAEA,QAAIF,MAAM,GAAG,CAAb,EAAgB;AACd,aAAO,EAAP;AACD;;AAED,WAAO,EAAEC,KAAF,GAAUC,MAAjB,EAAyB;AACvB,UAAIV,OAAO,CAACS,KAAD,CAAP,GAAiBD,MAArB,EAA6B;AAC3B,eAAO;AACLG,UAAAA,IAAI,EAAEF,KAAK,GAAG,CADT;AAELG,UAAAA,MAAM,EAAEJ,MAAM,IAAIR,OAAO,CAACS,KAAK,GAAG,CAAT,CAAP,IAAsB,CAA1B,CAAN,GAAqC,CAFxC;AAGLD,UAAAA,MAAM,EAAEA;AAHH,SAAP;AAKD;AACF;;AAED,WAAO,EAAP;AACD;AACF,C,CAED;AACA;;;AACA,SAASF,oBAAT,CAA8BN,OAA9B,EAAuC;AACrC,SAAOa,aAAP,CADqC,CAGrC;AACA;;AACA,WAASA,aAAT,CAAuBC,KAAvB,EAA8B;AAC5B,QAAIH,IAAI,GAAGG,KAAK,IAAIA,KAAK,CAACH,IAA1B;AACA,QAAIC,MAAM,GAAGE,KAAK,IAAIA,KAAK,CAACF,MAA5B;;AAEA,QAAI,CAACG,KAAK,CAACJ,IAAD,CAAN,IAAgB,CAACI,KAAK,CAACH,MAAD,CAAtB,IAAkCD,IAAI,GAAG,CAAP,IAAYX,OAAlD,EAA2D;AACzD,aAAO,CAACA,OAAO,CAACW,IAAI,GAAG,CAAR,CAAP,IAAqB,CAAtB,IAA2BC,MAA3B,GAAoC,CAApC,IAAyC,CAAhD;AACD;;AAED,WAAO,CAAC,CAAR;AACD;AACF,C,CAED;;;AACA,SAASZ,OAAT,CAAiBgB,KAAjB,EAAwB;AACtB,MAAIC,MAAM,GAAG,EAAb;AACA,MAAIR,KAAK,GAAGO,KAAK,CAACE,OAAN,CAAc,IAAd,CAAZ;;AAEA,SAAOT,KAAK,KAAK,CAAC,CAAlB,EAAqB;AACnBQ,IAAAA,MAAM,CAACE,IAAP,CAAYV,KAAK,GAAG,CAApB;AACAA,IAAAA,KAAK,GAAGO,KAAK,CAACE,OAAN,CAAc,IAAd,EAAoBT,KAAK,GAAG,CAA5B,CAAR;AACD;;AAEDQ,EAAAA,MAAM,CAACE,IAAP,CAAYH,KAAK,CAACN,MAAN,GAAe,CAA3B;AAEA,SAAOO,MAAP;AACD","sourcesContent":["'use strict'\n\nmodule.exports = factory\n\nfunction factory(file) {\n  var contents = indices(String(file))\n  var toPoint = offsetToPointFactory(contents)\n\n  return {\n    toPoint: toPoint,\n    toPosition: toPoint,\n    toOffset: pointToOffsetFactory(contents)\n  }\n}\n\n// Factory to get the line and column-based `point` for `offset` in the bound\n// indices.\nfunction offsetToPointFactory(indices) {\n  return offsetToPoint\n\n  // Get the line and column-based `point` for `offset` in the bound indices.\n  function offsetToPoint(offset) {\n    var index = -1\n    var length = indices.length\n\n    if (offset < 0) {\n      return {}\n    }\n\n    while (++index < length) {\n      if (indices[index] > offset) {\n        return {\n          line: index + 1,\n          column: offset - (indices[index - 1] || 0) + 1,\n          offset: offset\n        }\n      }\n    }\n\n    return {}\n  }\n}\n\n// Factory to get the `offset` for a line and column-based `point` in the\n// bound indices.\nfunction pointToOffsetFactory(indices) {\n  return pointToOffset\n\n  // Get the `offset` for a line and column-based `point` in the bound\n  // indices.\n  function pointToOffset(point) {\n    var line = point && point.line\n    var column = point && point.column\n\n    if (!isNaN(line) && !isNaN(column) && line - 1 in indices) {\n      return (indices[line - 2] || 0) + column - 1 || 0\n    }\n\n    return -1\n  }\n}\n\n// Get indices of line-breaks in `value`.\nfunction indices(value) {\n  var result = []\n  var index = value.indexOf('\\n')\n\n  while (index !== -1) {\n    result.push(index + 1)\n    index = value.indexOf('\\n', index + 1)\n  }\n\n  result.push(value.length + 1)\n\n  return result\n}\n"]},"metadata":{},"sourceType":"script"}